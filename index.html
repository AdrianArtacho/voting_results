<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>SHOWING – Votes</title>
  <meta name="theme-color" content="#000000" />

  <style>
    :root { color-scheme: dark; }
    html, body { height: 100%; margin: 0; background:#000; color:#fff; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; }
    .wrap { position: fixed; inset: 0; display: flex; flex-direction: column; padding: 20px; box-sizing: border-box; gap: 14px; }
    .top { display:flex; justify-content: space-between; align-items: baseline; gap: 12px; flex-wrap: wrap; }
    .title { font-size: 22px; font-weight: 650; letter-spacing: 0.2px; }
    .meta { opacity: .75; font-size: 13px; white-space: nowrap; }
    .board { flex: 1; display:flex; flex-direction: column; justify-content: center; gap: 14px; }

    .row {
      display: grid;
      grid-template-columns: minmax(120px, 240px) 1fr minmax(70px, 90px);
      align-items: center;
      gap: 12px;
    }

    .label { font-size: 18px; opacity: .95; overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    .pct { font-variant-numeric: tabular-nums; text-align: right; opacity: .9; }

    .barTrack {
      position: relative;
      height: 22px;
      border-radius: 999px;
      background: rgba(255,255,255,0.10);
      overflow: hidden;
    }
    .barFill {
      position: absolute; inset: 0 auto 0 0;
      width: 0%;
      background: rgba(255,255,255,0.85);
      border-radius: 999px;
      transition: width 600ms ease;
    }
    .barText {
      position: absolute; inset: 0;
      display: flex; align-items: center; justify-content: center;
      font-size: 12px; letter-spacing: .2px;
      color: rgba(0,0,0,0.75);
      mix-blend-mode: screen;
      pointer-events: none;
    }

    .footer {
      display:flex; justify-content: space-between; align-items: center;
      opacity: .7; font-size: 12px; gap: 10px; flex-wrap: wrap;
    }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .hidden { display:none !important; }
  </style>
</head>

<body>
  <div class="wrap">
    <div class="top">
      <div class="title" id="title">Votes</div>
      <div class="meta">
        <span id="total">0</span> votes · <span id="updated">--:--:--</span>
        <span id="windowInfo"></span>
      </div>
    </div>

    <div class="board" id="board"></div>

    <div class="footer">
      <div id="status">Loading…</div>
      <div class="mono" id="hint"></div>
    </div>
  </div>

<script>
(() => {
  const elBoard = document.getElementById("board");
  const elTotal = document.getElementById("total");
  const elUpdated = document.getElementById("updated");
  const elStatus = document.getElementById("status");
  const elHint = document.getElementById("hint");
  const elTitle = document.getElementById("title");
  const elWindowInfo = document.getElementById("windowInfo");

  const q = new URLSearchParams(location.search);
  const CSV_URL = q.get("csv") || "";
  const COL = Math.max(1, parseInt(q.get("col") || "1", 10));       // option column (1-based)
  const TSCOL = Math.max(1, parseInt(q.get("tscol") || "2", 10));   // timestamp column (1-based)
  const REFRESH_S = Math.max(0.5, parseFloat(q.get("refresh") || "2"));
  const TITLE = q.get("title") || "Votes";
  elTitle.textContent = TITLE;

  // Closing window params:
  // open=now | open=<ISO>
  // close=<ISO>
  // window=<seconds>  (auto close = open + window)
  const OPEN_RAW = (q.get("open") || "").trim();
  const CLOSE_RAW = (q.get("close") || "").trim();
  const WINDOW_S = q.get("window") ? Math.max(1, parseFloat(q.get("window"))) : null;

  function nowHMS() {
    const d = new Date();
    return d.toLocaleTimeString([], {hour:"2-digit", minute:"2-digit", second:"2-digit"});
  }
  function sleep(ms){ return new Promise(r => setTimeout(r, ms)); }

  // Freeze "open=now" at first load, so the window is stable.
  const OPEN_FIXED_MS = (() => {
    if (!OPEN_RAW) return null;
    if (OPEN_RAW.toLowerCase() === "now") return Date.now();
    const ms = Date.parse(OPEN_RAW);
    return Number.isFinite(ms) ? ms : null;
  })();

  const CLOSE_FIXED_MS = (() => {
    if (CLOSE_RAW) {
      const ms = Date.parse(CLOSE_RAW);
      return Number.isFinite(ms) ? ms : null;
    }
    if (OPEN_FIXED_MS !== null && WINDOW_S !== null) {
      return OPEN_FIXED_MS + WINDOW_S * 1000;
    }
    return null;
  })();

  function inWindow(tsMs) {
    if (!Number.isFinite(tsMs)) return false;
    if (OPEN_FIXED_MS !== null && tsMs < OPEN_FIXED_MS) return false;
    if (CLOSE_FIXED_MS !== null && tsMs > CLOSE_FIXED_MS) return false;
    return true;
  }

  function windowLabel() {
    if (OPEN_FIXED_MS === null && CLOSE_FIXED_MS === null) return "";
    const o = OPEN_FIXED_MS !== null ? new Date(OPEN_FIXED_MS).toLocaleTimeString() : "—";
    const c = CLOSE_FIXED_MS !== null ? new Date(CLOSE_FIXED_MS).toLocaleTimeString() : "—";
    return ` · window ${o}–${c}`;
  }

  // CSV parser (quotes)
  function parseCSV(text) {
    const rows = [];
    let row = [];
    let cell = "";
    let inQuotes = false;

    for (let i=0; i<text.length; i++) {
      const c = text[i];
      const n = text[i+1];

      if (c === '"' && inQuotes && n === '"') { cell += '"'; i++; continue; }
      if (c === '"') { inQuotes = !inQuotes; continue; }

      if (!inQuotes && (c === "," || c === "\n" || c === "\r")) {
        if (c === "\r" && n === "\n") i++;
        row.push(cell.trim());
        cell = "";
        if (c !== ",") { rows.push(row); row = []; }
        continue;
      }
      cell += c;
    }
    row.push(cell.trim());
    rows.push(row);
    return rows.filter(r => r.some(v => v !== ""));
  }

  async function fetchCSVFresh(url) {
    const u = new URL(url);
    u.searchParams.set("cb", (crypto?.randomUUID?.() || `${Date.now()}-${Math.random()}`));
    const res = await fetch(u.toString(), {
      cache: "no-store",
      headers: { "Cache-Control": "no-cache", "Pragma": "no-cache" }
    });
    if (!res.ok) throw new Error(`Fetch failed: ${res.status} ${res.statusText}`);
    return await res.text();
  }

  // DOM rows cache
  const rowsByKey = new Map();
  let lastOrder = [];

  function ensureRow(option) {
    if (rowsByKey.has(option)) return rowsByKey.get(option);

    const root = document.createElement("div");
    root.className = "row";

    const label = document.createElement("div");
    label.className = "label";
    label.textContent = option;

    const track = document.createElement("div");
    track.className = "barTrack";

    const fill = document.createElement("div");
    fill.className = "barFill";

    const barText = document.createElement("div");
    barText.className = "barText";
    barText.textContent = "";

    track.appendChild(fill);
    track.appendChild(barText);

    const pct = document.createElement("div");
    pct.className = "pct";
    pct.textContent = "0%";

    root.appendChild(label);
    root.appendChild(track);
    root.appendChild(pct);

    elBoard.appendChild(root);

    const obj = { root, label, fill, barText, pct };
    rowsByKey.set(option, obj);
    return obj;
  }

  function renderCounts(counts, totalIncluded, totalAll) {
    const entries = Array.from(counts.entries())
      .sort((a,b) => b[1]-a[1] || String(a[0]).localeCompare(String(b[0])));

    elTotal.textContent = String(totalIncluded);
    elUpdated.textContent = nowHMS();
    elWindowInfo.textContent = windowLabel();

    // Update
    for (const [opt, c] of entries) {
      const r = ensureRow(opt);
      const pct = totalIncluded > 0 ? (100 * c / totalIncluded) : 0;
      r.pct.textContent = `${pct.toFixed(pct < 10 ? 1 : 0)}%`;
      r.fill.style.width = `${pct}%`;
      r.barText.textContent = `${c}`;
    }

    // Hide missing
    const currentKeys = new Set(entries.map(([k]) => k));
    for (const [k, r] of rowsByKey.entries()) {
      r.root.classList.toggle("hidden", !currentKeys.has(k));
    }

    // Reorder only if changed
    const newOrder = entries.map(([k]) => k);
    const changed = newOrder.length !== lastOrder.length || newOrder.some((k,i) => k !== lastOrder[i]);
    if (changed) {
      const frag = document.createDocumentFragment();
      for (const k of newOrder) frag.appendChild(rowsByKey.get(k).root);
      elBoard.innerHTML = "";
      elBoard.appendChild(frag);
      lastOrder = newOrder;
    }

    // Status text
    if (OPEN_FIXED_MS !== null || CLOSE_FIXED_MS !== null) {
      elStatus.textContent = `Counting ${totalIncluded}/${totalAll} votes in window`;
    } else {
      elStatus.textContent = "Live";
    }
  }

  function aggregate(rows) {
    const optIdx = COL - 1;
    const tsIdx = TSCOL - 1;

    // Optional header skip if first row looks like labels
    const looksHeader = rows.length && /option|vote|label/i.test((rows[0][optIdx] || "")) && /ts|time|iso/i.test((rows[0][tsIdx] || ""));
    const dataRows = looksHeader ? rows.slice(1) : rows;

    const counts = new Map();
    let totalAll = 0;
    let totalIncluded = 0;

    for (const r of dataRows) {
      const opt = (r[optIdx] || "").trim();
      const ts = (r[tsIdx] || "").trim();
      if (!opt || !ts) continue;

      totalAll++;

      const tsMs = Date.parse(ts);
      if (!Number.isFinite(tsMs)) continue;

      if (!inWindow(tsMs)) continue;

      totalIncluded++;
      counts.set(opt, (counts.get(opt) || 0) + 1);
    }

    return { counts, totalIncluded, totalAll };
  }

  async function loop() {
    if (!CSV_URL) {
      elStatus.textContent = "Missing ?csv=… parameter";
      return;
    }

    elHint.textContent =
      `col=${COL} tscol=${TSCOL} refresh=${REFRESH_S}s` +
      (OPEN_RAW ? ` open=${OPEN_RAW}` : "") +
      (CLOSE_RAW ? ` close=${CLOSE_RAW}` : "") +
      (WINDOW_S ? ` window=${WINDOW_S}s` : "");

    while (true) {
      try {
        const txt = await fetchCSVFresh(CSV_URL);
        const rows = parseCSV(txt);
        const { counts, totalIncluded, totalAll } = aggregate(rows);
        renderCounts(counts, totalIncluded, totalAll);
      } catch (e) {
        elStatus.textContent = "Error: " + e.message;
      }
      await sleep(REFRESH_S * 1000);
    }
  }

  loop();
})();
</script>
</body>
</html>
